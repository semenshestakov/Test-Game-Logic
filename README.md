Код в файле main.py
# Вопрос 1
На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.
Объяснить плюсы и минусы обеих реализаций.
Пример:
def isEven(value):
return value % 2 == 0

def isEven(value): 
    return (value & 0x01) == 0

## Первая реализация
Плюсы:
+ Читабильность 
Минусы
- Производительность: В некоторых случаях операция взятия остатка может быть более затратной по сравнению с битовой операцией, особенно для больших чисел.

## Вторая реализация
Плюсы:
+ Производительность
+ Минимизация ошибок округления в случае с double (float)
Минусы:
- Читаемость кода

# Вопрос 2
На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. class (FIFOv1, FIFOv2)
Объяснить плюсы и минусы каждой реализации. 

##FIFOv1 (Список смежности)
Плюсы:
+ Гибкость размера: Списки смежности могут легко изменять размер, не требуя заранее определенного максимального размера.
+ Эффективность вставки и удаления: Вставка и удаление элементов в середине списка смежности происходят относительно быстро без необходимости перемещения других элементов.
Минусы:
- Больше памяти: В списке смежности требуется дополнительная память для хранения связей между элементами, что может стать недостатком при работе с большими объемами данных.

##FIFOv2 (Динамический массив)
Плюсы:
+ Эффективные операции доступа: Доступ к элементам в массиве осуществляется за константное время, что делает операции вставки и извлечения быстрее по сравнению с некоторыми другими структурами данных.
Минусы:
- Фиксированный размер: Динамический массив может иметь фиксированный размер, что может стать ограничением при необходимости увеличения размера.
- Вставка и удаление в середине массива неэффективны: Если нужно вставить или удалить элемент в середине массива, это может потребовать переноса всех последующих элементов.

# Вопрос 3
На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел.
Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным).
Объяснить, почему вы считаете, что функция соответствует заданным критериям.

Я выбрал вариант быстрой сортировкой + 3 указателя + сортировка маленьких масивов за (N^2)
Почему именно этот вариант?
1) быстрая сортировка позволяет добиться скорости O(N*log(N))
2) Не использовал margen sort - чтобы меньше зависить от доп памяти, не использвоал Хоара, потому что 2 указателя не стабильны, поэтому 3.
3) Использовал обычную сортировку за O(N^2) для маленьких массиово, чтобы было меньше рекурсивных вызовов. Это позволяет ускорить на несколько процентов работу.

Если бы были числа по условию были бы в диапозоне и целочисленные, то я бы использовал "K разрядную сортировку" например длинна массива  N и мы записываем числа int32, то время было бы линейно O(K*N), где K = 32





